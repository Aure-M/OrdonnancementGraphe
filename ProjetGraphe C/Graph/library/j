#include "Graph.h"

/* Affichage matrice d'ajacence  */

void affichageMatAdjacence(bool **tab, int len)
{
    printf("-----------MATRICE D'ADJACENCE----------\n\n    ");
    for (int i = 0; i < len; i++)
    {
        printf("%d ", i + 1);
    }
    printf("\n");
    for (int i = 0; i < len; i++)
    {

        if ((i + 1) / 10 >= 1)
        {
            printf("%d ", i + 1);
        }
        else
        {
            printf("%d  ", i + 1);
        }

        for (int j = 0; j < len; j++)
        {
            if (tab[i][j] == true)
                printf("\033[1;31m O\033[0m");
            else
                printf(" X");
        }
        printf("\n");
    }
    printf("\n---------------------------------------\n\n");
}

void affichageMatriceValeurs(Graph *graph)
{
    printf("-----------MATRICE DES VALEURS----------\n\n    ");
    for (int i = 0; i < graph->nbrSommets; i++)
    {
        printf("%d ", i + 1);
    }
    printf("\n");
    for (int i = 0; i < graph->nbrSommets; i++)
    {

        if ((i + 1) / 10 >= 1)
        {
            printf("%d ", i + 1);
        }
        else
        {
            printf("%d  ", i + 1);
        }

        for (int j = 0; j < graph->nbrSommets; j++)
        {
            if (graph->matriceAdjacence[i][j] == true)
                printf("\033[1;34m %d\033[0m", graph->durees[i]);
            else
                printf(" *");
        }
        printf("\n");
    }
    printf("\n---------------------------------------\n\n");
}

Graph *initGraph(int nbrSommets, File **tab_Duree_Et_Contraintes)
{
    Graph *graph = malloc(sizeof(*graph));
    int tmpNode = -1;
    int index = -1;
    if (graph == NULL)
    {
        perror("Erreur pendant la création du graphe");
        exit(EXIT_FAILURE);
    }
    graph->nbrSommets = nbrSommets;
    graph->durees = malloc(nbrSommets * sizeof(int));

    /*
        Puisque le premier élément de chaque case de notre tableau(tab_Duree_Et_Contraintes)
        correspond à la duree de la tache représentée par ce noeud nous allons retirer pour chaque
        case le premier élément de sa liste pouur remplir le tableau de durée
    */

    for (int i = 0; i < nbrSommets; i++)
    {
        index = defiler(tab_Duree_Et_Contraintes[i]);
        graph->durees[index - 1] = defiler(tab_Duree_Et_Contraintes[i]);
    }

    graph->matriceAdjacence = malloc(nbrSommets * sizeof(bool *));

    /*
        Initialisation de la matrice d'adjacence
    */

    for (int i = 0; i < nbrSommets; i++)
    {
        graph->matriceAdjacence[i] = malloc(nbrSommets * sizeof(bool));
        for (int j = 0; j < nbrSommets; j++)
        {
            graph->matriceAdjacence[i][j] = 0;
        }
    }
    /*
        Remplissage de la matrice d'adjacence
    */
    for (int i = 0; i < nbrSommets; i++)
    {
        while (tab_Duree_Et_Contraintes[i]->firstElement != NULL)
        {
            tmpNode = defiler(tab_Duree_Et_Contraintes[i]);
            graph->matriceAdjacence[tmpNode - 1][i] = 1;
        }
    }

    free(tab_Duree_Et_Contraintes);

    return graph;
}
/*----------------------- générer tableau de contraintes ----------------------*/

File **genTableau_Duree_Contraintes(Graph *graph, int *sommet_a_retenir)
{

    int sommetRetenus = 0;
    bool estUnsommetIsole;

    File **tab_Durees_Contraintes = (File **)malloc(sizeof(File *));
    if (tab_Durees_Contraintes == NULL)
    {
        perror("Echec de l'allocation de mémoire\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < graph->nbrSommets; i++)
    {
        estUnsommetIsole = true;
        tab_Durees_Contraintes[sommetRetenus] = initialisation();

        for (int j = 0; j < graph->nbrSommets; j++)
        {
            if (graph->matriceAdjacence[i][j] == true || graph->matriceAdjacence[j][i] == true)
            {
                estUnsommetIsole = false;
            }
            if (graph->matriceAdjacence[j][i] == true)
            {
                if (tab_Durees_Contraintes[sommetRetenus]->firstElement == NULL)
                {
                    enfiler(tab_Durees_Contraintes[sommetRetenus], i + 1);
                    enfiler(tab_Durees_Contraintes[sommetRetenus], graph->durees[i]);
                }
                enfiler(tab_Durees_Contraintes[sommetRetenus - 1], j + 1);
            }
        }

        if (estUnsommetIsole == true)
        {
            freeFile(tab_Durees_Contraintes[sommetRetenus]);
        }
        else
        {
            sommetRetenus++;
            tab_Durees_Contraintes = (File **)realloc(tab_Durees_Contraintes, (sommetRetenus + 1) * sizeof(File *));
            if (tab_Durees_Contraintes == NULL)
                printf("Echec de l'allocation\n");
        }
    }
    *sommet_a_retenir = sommetRetenus;
    return tab_Durees_Contraintes;
}
/*-----------------------copie----------------------*/

Graph *copie(Graph *model)
{
    int nbrSommets = model->nbrSommets;
    Graph *graph = malloc(sizeof(Graph));

    graph->durees = malloc(nbrSommets * sizeof(int));

    graph->matriceAdjacence = malloc(nbrSommets * sizeof(bool *));

    graph->nbrSommets = model->nbrSommets;

    /* Copie du tableau de durées */
    for (int i = 0; i < nbrSommets; i++)
    {
        graph->durees[i] = model->durees[i];
    }

    /* Copie de la matrice d'adjacence */
    for (int i = 0; i < nbrSommets; i++)
    {
        graph->matriceAdjacence[i] = malloc(nbrSommets * sizeof(bool));
        for (int j = 0; j < nbrSommets; j++)
        {
            graph->matriceAdjacence[i][j] = model->matriceAdjacence[i][j];
        }
    }

    return graph;
}

/*---------------------détection de circuit--------------*/

File *detectPointEntree(Graph *graph)
{
    File *result = initialisation();
    bool isAnEntryPoint = true;
    int i = 0, j = 0;
    for (i = 0; i < graph->nbrSommets; i++)
    {
        isAnEntryPoint = true;
        for (j = 0; j < graph->nbrSommets; j++)
        {
            if (graph->matriceAdjacence[j][i] == 1)
            {
                isAnEntryPoint = false;
                break;
            }
        }
        if (isAnEntryPoint)
        {
            enfiler(result, i + 1);
        }
    }
    return result;
}

File *detectPointSortie(Graph *graph)
{
    File *result = initialisation();
    bool isAnEndPoint = true;
    int i = 0, j = 0;
    for (i = 0; i < graph->nbrSommets; i++)
    {
        isAnEndPoint = true;
        for (j = 0; j < graph->nbrSommets; j++)
        {
            if (graph->matriceAdjacence[i][j] == 1)
            {
                isAnEndPoint = false;
                break;
            }
        }
        if (isAnEndPoint)
        {
            enfiler(result, i + 1);
        }
    }
    return result;
}

/*---------------------détection de circuit--------------*/
bool detectionCircuit(Graph *graph)
{
    Graph *copieGraphe = copie(graph);
    File *f1 = NULL, *f2 = NULL;
    File **tmp = NULL;
    int tmpNode = -1, sommets_restants = graph->nbrSommets, sommetsDeTabContraintes = 0;

    f1 = detectPointEntree(copieGraphe);
    f2 = detectPointSortie(copieGraphe);

    while (f1->firstElement != NULL || f2->firstElement != NULL)
    {

        /* Suppression des sommets présents dans f1 */
        while (f1->firstElement != NULL)
        {
            tmpNode = defiler(f1);
            for (int i = 0; i < graph->nbrSommets; i++)
            {
                copieGraphe->matriceAdjacence[i][tmpNode - 1] = 0;
                copieGraphe->matriceAdjacence[tmpNode - 1][i] = 0;
            }
            sommets_restants--;
        }

        /* Suppression des sommets présents dans f1 */
        while (f2->firstElement != NULL)
        {
            tmpNode = defiler(f2);
            for (int i = 0; i < graph->nbrSommets; i++)
            {
                copieGraphe->matriceAdjacence[i][tmpNode - 1] = 0;
                copieGraphe->matriceAdjacence[tmpNode - 1][i] = 0;
            }
            sommets_restants--;
        }

        /* Si il ne reste qu'un seul sommet le graphe ne peut pas être un circuit */
        if (sommets_restants <= 1)
            return false;

        tmp = genTableau_Duree_Contraintes(copieGraphe, &sommetsDeTabContraintes);
        free_graph(copieGraphe);
        copieGraphe = initGraph(sommetsDeTabContraintes, tmp);
        f1 = detectPointEntree(copieGraphe);
        f2 = detectPointSortie(copieGraphe);
    }

    freeFile(f1);
    freeFile(f2);
    free(tmp);

    return true;
}

bool a_un_arc_negatif(Graph *graph)
{
    for (int i = 0; i < graph->nbrSommets; i++)
    {
        if (graph->durees[i] < 0)
        {
            printf("Le sommet %d a une durée négative ( %d )\n", i + 1, graph->durees[i]);
            return true;
        }
    }
    printf("Ce graphe n'a pas d'arc négatif ^^ \n");
    return false;
}

/*--------------------rangs sommets-------------------*/

int *rangsSommets(Graph *graph)
{

    Graph *copieGraphe = copie(graph);
    File **tmp = NULL;
    File *f1 = NULL;
    int tmpNode = -1, rangActuel = 0, sommetsDeTabContraintes = 0;
    int *rangs = malloc(graph->nbrSommets * sizeof(int));
    f1 = detectPointEntree(copieGraphe);
    affichageMatAdjacence(copieGraphe->matriceAdjacence, copieGraphe->nbrSommets);
    while (f1->firstElement != NULL)
    {

        while (f1->firstElement != NULL)
        {
            tmpNode = defiler(f1);
            for (int i = 0; i < graph->nbrSommets; i++)
            {
                copieGraphe->matriceAdjacence[i][tmpNode - 1] = 0;
                copieGraphe->matriceAdjacence[tmpNode - 1][i] = 0;
            }
            //affichageMatAdjacence(copieGraphe->matriceAdjacence, copieGraphe->nbrSommets);
            rangs[tmpNode - 1] = rangActuel;
            sleep(2);
        }

        tmp = genTableau_Duree_Contraintes(copieGraphe, &sommetsDeTabContraintes);

        printf("Contraintes \n");
        for (int i = 0; i < sommetsDeTabContraintes; i++)
        {
            afficherFile(tmp[i]);
        }

        sleep(3);
        free_graph(copieGraphe);
        copieGraphe = initGraph(sommetsDeTabContraintes, tmp);
        f1 = detectPointEntree(copieGraphe);
        printf("\nF1 ");
        afficherFile(f1);
        rangActuel++;
    }

    freeFile(f1);

    return rangs;
}

void affichageRangsSommets(Graph *graph)
{
    int *rangs = rangsSommets(graph);
    printf("------ Rangs des sommets -----");
    for (int i = 0; i < graph->nbrSommets; i++)
    {
        printf("%d -> %d\n", i + 1, rangs[i]);
    }
    printf("----------------------------\n");
}

int *calendrierAuPlusTot(Graph *graph)
{
    int *durees = graph->durees, *calendrier = malloc(graph->nbrSommets * sizeof(int));
    int tmp;

    for (int i = 0; i < graph->nbrSommets; i++)
    {
        tmp = 0;
        for (int j = 0; j < graph->nbrSommets; j++)
        {
            if (graph->matriceAdjacence[j][i] == true)
            {
                tmp = (calendrier[j] + durees[j]) > tmp ? (calendrier[j] + durees[j]) : tmp;
            }
        }

        calendrier[i] = tmp;
    }

    for (int i = 0; i < graph->nbrSommets; i++)
    {
        printf("%d = %d\n", i + 1, calendrier[i]);
    }

    free(calendrier);
    return NULL;
}
int *calendrierAuPlusTard(Graph *graph)
{

    return NULL;
}
int *marges(Graph *graph)
{

    return NULL;
}
/*--------------------liberer graphe-------------------*/
void free_graph(Graph *graph)
{

    if (graph->matriceAdjacence != NULL)
        free(graph->matriceAdjacence);

    if (graph->durees != NULL)
        free(graph->durees);

    free(graph);
}
